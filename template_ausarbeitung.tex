\documentclass[a4paper,ngermanб,12pt]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% allgemeine LaTeX Pakete laden
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Mathematik
\usepackage{amsmath}  % American Math Society Packete: general
\usepackage{amsfonts} % American Math Society Packete: more fonts
\usepackage{amssymb}  % American Math Society Packete: more symbols
\usepackage{stmaryrd} % St Mary Road symbols for theoretical computer science
\usepackage[framed,hyperref,amsmath,thmmarks]{ntheorem} % en­hance­ments for the­o­rem-like en­vi­ron­ments

% Umlaute tippen
\usepackage[utf8]{inputenc}

% Wörterbuch für korrekte Silbentrennung, Titel von Abschnitten (Abbildung, Zusammenfassung, Literaturverzeichnis)
\usepackage{babel}

% Blockweises auskommentieren mit \begin{comment}\end{comment}
\usepackage{verbatim}

% Grafiken 
\usepackage{graphics,graphicx} % Bilder
\usepackage{color,xcolor} % Farbnamen
\graphicspath{{figures/}} % Es gibt ein Unterverzeichnis, wo alle Bilder liegen. Durch diesen Befehl muss man nicht jedes mal den Dateipfad angeben

%Listen
\usepackage{enumerate}
\usepackage{enumitem}

%Tabellen
\usepackage{tabularx}
\usepackage{booktabs}% Statt \hline kann \toprule, \midrule und \bottomrule verwendet werden.
\usepackage{longtable}
\usepackage{tabularray}
\usepackage{multicol} % to use columns with multiple rows
%\usepackage{multirow} % provides a construction for table cells that span more than one row

% Algorithmen
\usepackage{algorithm}
\usepackage{algorithmic}
% Algorithmen auf Deutsch %
\renewcommand{\algorithmicrequire}{\textit{Eingabe:}}
\renewcommand{\algorithmicensure}{\textit{Ausgabe:}}
\floatname{algorithm}{Algorithmus}

%Referenzen
\usepackage[unicode,pdfmenubar,linktoc=all,hidelinks,bookmarks]{hyperref} % ermöglicht PDF-Verklinkungen
\usepackage{url} % al­lows line­breaks at cer­tain char­ac­ters in urls/ e-mail adresses/ paths
%\usepackage{thmtools}%für nameref von Theoremen, aber dann sind Nummern bei Lemma/Korollar weg
\usepackage[nameinlink, compress, sort]{cleveref}% Kommando \Cref{label} schreit automatisch Abbildung/Abschnitt/Tabelle vor die Referenz
\usepackage{nameref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Tikz Grafiken
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{tikz}
% Zusätzliche Tikz-Module einbinden
\usetikzlibrary{automata} 
\usetikzlibrary{arrows}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}

% Tikz-Stil für Automaten
\tikzset{
	myautomat/.style = {
		>=stealth, shorten >= 1pt,auto,node distance=2cm,
	}
}
\tikzstyle{initial}+=[initial text=]

%Definiere hier eigene Tikz-Styles, damit alle Grafiken (z.B. alle Graphen) in einem einheitlichen Stil sind

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Literatur
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[style=alphabetic,backend=biber]{biblatex}
\bibliography{literatur}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Theoreme 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Definiere Umgebungen für Aussagen
\newtheorem{theorem}{Theorem}% (wichtiger Satz) Höhepunkt in der Entwicklung einer Theorie
\newtheorem{corollary}[theorem]{Korollar}% (Folgerung) einfach/ trivial aus vorhergehenden Sätzen zu folgern 
\newtheorem{lemma}[theorem]{Lemma}% (Hilfssatz) rein technische Aussage, als Schlüsselgedanke für anderen Beweis
\newtheorem{proposition}[theorem]{Proposition}%  Mittelding aus Hilfssatz und Theorem
\newtheorem{observation}[theorem]{Beobachtung}

\newtheorem{example}[theorem]{Beispiel}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{remark}[theorem]{Bemerkung}

% Beweis-Umgebung
\theorembodyfont{\upshape}
\theoremstyle{nonumberplain}
\theoremheaderfont{\itshape}
\theoremsymbol{\ensuremath{\Box}}%QED Symbol am Beweisende
\newtheorem{proof}{Beweis}

% Zeilennummern
\usepackage{lineno}

%%%%%%%%%%%    Meta Informationen   %%%%%%%%%%%%%%
\title{Min-Cost Max-Flow\\
{\normalsize Proseminar:  Fortgeschrittene Algorithmen für Programmierwettbewerbe
}
}
\author{Vladimir Vassilyev}
\date{\today}

\begin{document}

\maketitle

%%%%%%%%%%%    Ausarbeitung   %%%%%%%%%%%%%%
\linenumbers % Ab hier werden die Zeilen gezählt
	
\begin{abstract}

In meiner Ausarbeitung geht es um Min-Cost Max-Flow - ein Algorithmus, das echt hilfreich bei der Lösung verschiedenster Problemen sein kann und dabei ganz leicht zu verstehen und implementieren ist. Ich werde heute Implementierung von diesem Algorithmus zeigen und erklären. Außerdem will ich paar Beispielaufgaben, u.a. aus den echten Programmierwettbewerben vorzeigen, die mithilfe von Min-Cost Flow gelöst werden können.
\end{abstract}

\section{Einleitung}
\label{sec:intro}

  Alles in unserer Welt ist irgendwie miteinander verbunden. Diese enge Verbundenheit kann mithilfe von Graph bezeichnet werden. Graph ist eine Datenstruktur, die in der Programmierung, u.a. in Programmierwettbewerben seit langem verwendet wurde. Diese Datenstruktur hilft uns, komplexe Probleme aus der echten Welt auf eine neue Ebene zu reduzieren und besseres Verständnis davon zu kriegen. In meiner Arbeit betrachte ich das Algorithmus Min-Cost (Max) Flow näher.
 
\newpage

\section{Problemstellung}



\subsection{Definition}

 Wie kann man denn Min-Cost Max-Flow beschreiben? Im Buch "Competitive Programming 4"  wurde es so beschrieben: \newline 
  \normalsize
   The Min Cost Flow problem is the problem of finding the cheapest possible way of sending a certain amount of (not necessarily the max) flow through a flow network.\cite{Halim2018} \newline
   Kurz gesagt, man soll den effizientesten Weg mit maximalem Fluss aus dem gesamten Graph finden. Effizient bedeutet in diesem Kontext, dass die Flusswege auch ihre Kosten haben können. Damit es bisschen verständlicher wird, gebe ich eine typische Aufgabe zu diesem Algorithmus.

\subsection{Beispiel}
Hier ist ein Beispiel der Aufgabe, der mithilfe von Min-Cost Max-Flow gelöst wird:

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{figures/beispiel1.png}
    \caption{Fluss-Graph \cite{Halim2018, Figure 9.23}}
\end{figure}
Wir haben hier einen Graph, wobei jede Kante ihre Kosten hat, die oben geschrieben sind. Jeder Pfad hat eine Flusskapazität von 10 Einheiten. In dieser Aufgabe wollen wir 20 Einheiten von Fluss von A nach D übertragen. Wir sollen den effizientesten Weg dazu finden. Es gibt insgesamt drei mögliche Lösungen:
\begin{itemize}
    \item A$\rightarrow$D + A$\rightarrow$B$\rightarrow$D = 1*10 + (3+4)*10 = 80 
    \item A$\rightarrow$D + A$\rightarrow$C$\rightarrow$D = 1*10 + (3+5)*10 = 90 
    \item A$\rightarrow$C$\rightarrow$D + A$\rightarrow$B$\rightarrow$D = (3+4)*10 + (3+5)*10 = 150 
\end{itemize}
Wie wir sehen können braucht die erste Variante am wenigsten Kosten, deswegen wählen wir die aus. Aber was wenn wir eine komplexere Aufgabe haben? Wie genau funktioniert das Algorithmus? Das erkläre ich im nächsten Kapitel.

\newpage

\section{Implementierung}

\subsection{Auswahl des Algorithmus}
Jetzt betrachten wir, wie Min-Cost Flow Algorithmus am besten implementiert werden kann. Bevor wir mit der Implementierung beginnen, sollen wir einen Aspekt betrachten: die Kosten können auch negativ sein.\cite{Halim2018} \newline Warum ist das wichtig? In manchen Situationen können negative Zyklen entstehen. Ein negativer Zyklus im Kosten-Netzwerk entsteht, wenn die Summe der Kosten aller Kanten im Zyklus negativ ist. Diese können mit dem \textbf{Bellman-Ford-Algorithmus} erkannt werden. Sie sollten beseitigt werden, da der Fluss durch solche Zyklen in der Praxis nicht zulässig ist. Betrachten wir einen negativen Kostenzyklus: Wenn der gesamte Fluss diesen Zyklus durchlaufen muss, verringern sich die Gesamtkosten mit jedem abgeschlossenen Zyklus. Dies würde zu einer Endlosschleife führen, wenn man die Gesamtkosten minimieren möchte. \cite{GeeksforGeeks2023}(übersetzt durch DeepL)

\subsection{Schrittweise Aufteilung}
Ian Kiprono, Senior Software Developer bei PInterest, hat einen Artikel zu diesem Thema auf der Webseite geeksforgeeks.com hochgeladen. Lasst uns, mithilfe von obengenanntem Artikel\cite{GeeksforGeeks2023}, zuerst das Algorithmus schrittweise aufteilen. Die grundsätzliche Idee ist wie folgt:
\begin{enumerate}
    \item Gegeben sei ein Graph. Jede Kante in diesem Graph hat ihre Kosten $\mathbf{cost}$, Kapazität $\mathbf{cap}$ und die Flussmenge, die durch diese Kante gesendet wird $\mathbf{flow}$. 
    \item Gegeben seien der Quellknoten $\mathbf{src}$ und der Senkenknoten $\mathbf{sink}$. Wir haben eine Hilfsfunktion, die überprüft, ob es noch einen gültigen Pfad von $\mathbf{sink}$ nach $\mathbf{src}$ gibt. Wenn es keinen mehr gibt, terminiert der Algorithmus.
    \item Soweit es einen gültigen Pfad gibt, wählen wir einen Pfad von $\mathbf{sink}$ nach $\mathbf{src}$ (entweder random oder mit den minimalen Kosten). Wir berechnen den maximalen Fluss, den wir entlang dieses Pfades senden können.
    \item Nachdem wir einen Pfad ausgewählt und den Fluss berechnet haben, sollen wir diesen Pfad aktualisieren, indem wir die Kapazität aller Kanten auf dem Pfad aktualisieren. 
    \item Am Ende bekommen wir die gesamte Flussmenge $\mathbf{totflow}$, die wir in dem Graph von $\mathbf{sink}$ nach $\mathbf{src}$ senden können und die gesamten Kosten dafür - $\mathbf{totcost}$.
\end{enumerate}
 Die genauere Implementierung kann von der Aufgabe variieren, aber die Grundidee ist so.
\subsection{Code}
Das Algorithmus, das Min-Cost Max-Flow Problem löst, besteht tatsächlich aus drei Unteralgorithmen\cite{GeeksforGeeks2023}:
\begin{enumerate}
    \item Wieviel Fluss kann gesendet werden? (Wir können es maxFlow() nennen)
    \item Den Fluss aktualisieren (updateFlow())
    \item Hilfsfunktion, die überprüft, ob es immer noch einen gültigen Pfad von Quelle zur Senke gibt. (search())
\end{enumerate}
Unten können wir den Pseudocode für jeden Unteralgorithmus sehen.
\begin{algorithm}
	\caption{maxFlow}
	\label{alg:BFS}
	\begin{algorithmic} []
		\REQUIRE Kapazitätenarray $cap$, Flussarray $flow$, Quellknoten $src$, Senkenknoten $sink$
		%\ENSURE BFS
		
		%\STATE	$Q$.enqueue($s$)			
		%\STATE mark $s$ as visited
		%\WHILE{$Q$ is not empty}
		%\STATE	$v$ = $Q$.dequeue( )			
		%\FORALL{neighbors $w$ of $v$}
		%\IF{$w$ is not visited}
		%\STATE	$Q$.enqueue($w$)
		%\STATE	mark $w$ as visited
		%\ENDIF
		%\ENDFOR
		%\ENDWHILE
        \STATE $amt \gets INF$
        \STATE $x \gets sink$     
        \WHILE{$x \neq src$}
        \IF{$flow[x][dad[x]] \neq 0$}
        \STATE $val \gets flow[x][dad[x]]$
        \ELSE
        \STATE $val \gets cap[dad[x]][x] - flow[dad[x]][x]$
        \ENDIF
        \STATE $amt \gets \min( amt, val  )$
        \STATE $x \gets dad[x]$

        \ENDWHILE
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
	\caption{updateFlow}
	\label{alg:BFS}
	\begin{algorithmic} []
		\REQUIRE Kostenarray $cost$, Flussarray $flow$, Quellknoten $src$, Senkenknoten $sink$
  
        \WHILE{$x \neq src$}        
        \IF{$flow[x][dad[x]] \neq 0$}
        
        \STATE $flow[x][dad[x]] \gets flow[x][dad[x]] - amt$
        \STATE $totcost \gets totcost - amt*cost[x][dad[x]]$
        \ELSE
        \STATE $flow[x][dad[x]] \gets flow[x][dad[x]] + amt$
        \STATE $totcost \gets totcost + amt*cost[x][dad[x]]$
        \ENDIF
        \STATE $totflow \gets totflow + amt$

        
        \STATE $x \gets dad[x]$
        \ENDWHILE
	\end{algorithmic}
\end{algorithm}
%Hier ist Implementierung der Hilfsfunktion, die überprüft, ob es immer noch einen gültigen Pfad in dem Graph gibt.
\begin{algorithm}[H]
	\caption{search}
	\label{alg:BFS}
	\begin{algorithmic} []
		\REQUIRE Quellknoten $src$, Senkenknoten $sink$
		\ENSURE $found[sink]$

        \STATE $Arrays$.fill($found$, false)
        \STATE $Arrays$.fill($dist$, INF)
        \STATE $dist[src] \gets 0$        
        \WHILE{$src \neq N$}
        \STATE $best \gets N$
        \STATE $found[src] \gets true$
        \FOR{$k \gets 0; k< N; k \gets k+1$}
        \IF{$found[k]$}
        \STATE continue
        \ENDIF
        \IF{$flow[k][src] \neq 0$}
        \STATE $val \gets dist[src] + pi[src] - pi[k] - cost[k][src]$
        \IF{$dist[k] > val$}
        \STATE $dist[k] \gets val$
        \STATE $dad[k] \gets src$
        \ENDIF
        \ENDIF
        \IF{$flow[src][k] < cap[src][k]$}
        \STATE $val \gets dist[src] + pi[src] - pi[k] + cost[k][src]$
        \IF{$dist[k] > val$}
        \STATE $dist[k] \gets val$
        \STATE $dad[k] \gets src$
        \ENDIF
        \ENDIF 
        \IF{$dist[k]<dist[best]$}
        \STATE $best \gets k$
        \ENDIF
        \ENDFOR
        \STATE $src \gets best$
        \ENDWHILE
        \FOR{$k \gets 0; k< N; k \gets k+1$}
        \STATE $pi[k] \gets \min( pi[k]+dist[k], INF)$
        \ENDFOR
        \RETURN $found[sink]$
        
	\end{algorithmic}
\end{algorithm}
\newpage
\section{Laufzeit und Korrektheit}

In dieser Abteilung besprechen wir die Laufzeit aller Teile des obenbeschriebenen Algorithmus. Ich will außerdem über die Optimierungsmöglichkeiten erzählen und die effizienteste Variante analysieren.

\subsection{Laufzeit der naiven Lösung}

Lasst uns zuerst mit dem Algorithmus anfangen, den wir früher in dieser Arbeit implementiert haben.
\begin{enumerate}
    \item maxFlow() - Wir gehen von $\mathbf{sink}$ zu $\mathbf{src}$ und vergleichen dabei $\mathbf{val}$ und $\mathbf{amt}$. Die Vergleichung braucht $\mathbf{O(1)}$ und sie wird im schlimmsten Fall $\mathbf{V}$ mal durchgeführt. Insgesamt bekommen wir dann $\mathbf{O(V)}$.
    \item updateFlow() - Der Prinzip ist gleich: wir gehen durch den Pfad und aktualisieren den Flusswert und die Kosten für $\mathbf{O(1)}$. Insgesamt bekommen wir wieder $\mathbf{O(V)}$.
    \item search() - Die $\mathbf{while}$-Schleife wird $\mathbf{V}$ mal durchgeführt. Die innere $\mathbf{for}$-Schleife läuft auch $\mathbf{V}$ mal. Insgesamt bekommen wir also $\mathbf{O(V^{2})}$.
\end{enumerate}
Die $\mathbf{search()}$-Funktion wird im schlimmsten Fall $\mathbf{F}$ mal gerufen, wobei $\mathbf{F}$ für den maximalen Fluss im Graph steht. Da $\mathbf{O(V^{2})}$ die $\mathbf{O(V)}$ dominiert, bekommen wir die gesamte Laufzeit von $\mathbf{O(V^{2} \cdot F)}$. Dieser Algorithmus passt also ganz gut für Lösung des Problems in kleinen Graphen. Es gibt aber eine andere Lösung, die viel effizienter ist.

\subsection{Optimierungsmöglichkeiten}
Wir können drei wichtigste Unterprobleme definieren.\cite{Cruz2023} Die sind für genauere Analyse der Laufzeit von Algorithmen in polynomialer Zeit hilfreich.
\begin{itemize}
    \item Shortest $(s,t)$-path Problem – Wir haben einen Digraphen $G$, zwei bestimmte Knoten $\mathbf{s}$ und $\mathbf{t}$ und einen Kostenvektor $c \in \mathbb{Q}^m$. Die Aufgabe besteht darin, einen Pfad von $\mathbf{s}$ nach $\mathbf{t}$ mit minimalen Gesamtkosten zu finden.
    
    \item Transshipment problem –  die Variante von MCF, bei der keine Kantenkapazitäten vorhanden sind (oder, gleichbedeutend, alle Kantenkapazitäten sehr groß sind) 
    
    \item Negative-cycle detection problem –  Wir haben einen Digraphen $G$ und einen Kostenvektor $c \in \mathbb{Z}^m$. Die Aufgabe besteht darin, zu überprüfen, ob
 es in $G$ einen gerichteten Zyklus gibt, dessen Gesamtkosten negativ sind. (übersetzt durch DeepL)
\end{itemize}
Da das Problem schon seit langer Zeit geforscht wurde, gibt es mehrere Lösungen, die für polynomielle Zeit ausgeführt werden. \cite{Cruz2023}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Jahr & Laufzeit & Quelle \\ \hline
1972 & $O(E \log U) \cdot SP$ & Edmonds und Karp \\ \hline
1980 & $O(E \log C) \cdot MF$ & Röck \\ \hline
1984 & $O(E^{2} \log V) \cdot SP$ & Orlin, Fujishige \\ \hline
1985 & $O(E^{2} \log V) \cdot MF$ & Tardos \\ \hline
1986 & $O(V^{2} \log V) \cdot SP$ & Galil und Tardos \\ \hline
1988 & $O(E \log V) \cdot SP$ & Orlin \\ \hline
\end{tabular}
\end{center}
Dabei steht $\mathbf{E}$ für die Anzahl der Kanten, $\mathbf{V}$ für die Anzahl der Knoten, $\mathbf{U}$ für die maximale Kapazität im Graph und $\mathbf{C}$ für die maximale Kosten. $\mathbf{SP}$ steht für Shortest-Path Problem und $\mathbf{MF}$ für Maximum-Flow. Orlins Algorithm gilt also als der effizienteste nicht-randomisierte Algorithmus für Min-Cost Flow Problem. Im nächsten Abschnitt betrachten wir diesen Algorithmus näher. 

\subsection{Algorithm von Orlin (1988)}
Orlin hat seine Lösung auf Edmond-Karps Algorithmus basiert.\cite{orlin1988} Er hat drei Vorbedingungen genannt, die wichtig zu bemerken sind:
\begin{itemize}
    \item Alle Kantenkosten sind nicht negativ.
    \item Für jedes Knotenpaar i,j in Knotenmenge V gibt es eine Kante in Kantenmenge E von i nach j.
    \item Es gibt maximal eine Kante zwischen beliebigen zwei Knoten i und j, zum Beispiel, es kann nur entweder (i,j)- oder (j,i)-Kante geben, nicht die beiden in einem Graph.
\end{itemize}
Der Algorithmus funktioniert, nur wenn der Graph allen diesen Vorbedingungen zustimmt. Der Prinzip seiner Lösung basiert sich auf RHS-Scaling (Right Hand-Side) mit bestimmten Änderungen:
\begin{enumerate}
    \item Wir ziehen eine Kante, sobald sie starkbasisch wird.
    \item Wir lassen in einigen Fällen eine anomale Sondererhöhung zu,
wenn der Abfluss eines Versorgungsknotens i sein Angebot b(i) übersteigt oder der Zufluss eines
Nachfrageknotens i seine Nachfrage -b(i) übersteigt.
    \item Wir verlangen, dass alle Lösungen Spannbaumlösungen sind,
d. h. Bögen mit positiven Flüssen
enthalten keine Zyklen.
    \item Wir verlangen nicht mehr, dass $\Delta$ eine Potenz von 2 ist,
und wir verlangen auch nicht mehr, dass $\Delta$ bei jeder Iteration durch
2 geteilt wird. 
\end{enumerate}

\newpage

\section{Beispiele}
Hier ist ein kurzer Überblick zu einer echten Programmieraufgabe. \newline
Das Alfalfas-Team besucht die Chinesische Mauer. Sie wollen sie von Anfang bis Ende überqueren,
aber einige Teile der Mauer wurden für Touristen umgebaut und es muss eine Mautgebühr bezahlt werden. Also
kauften sie eine Karte, auf der die Mauer als Raster mit 5 Zeilen und n Spalten dargestellt war. Jeder Ort war
mit einer Ziffer markiert, die die Höhe der Mautgebühr angibt. Die Alfalfas möchten, dass Sie ein Programm schreiben, um
den Weg zu finden, wie man die Chinesische Mauer von Spalte 0 bis n-1 mit den geringsten Kosten überqueren kann. Die Eingabe sieht wie folgt aus:
\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{figures/great wall.png}
    \caption{Chinesische Mauer Eingabe \cite{ChWall}}
\end{figure}


%\Cref{sec:intro,fig:automat,alg:BFS,theo:aussage}.

%\begin{figure}
	%\centering
	%\begin{tikzpicture}[myautomat]
		%\node[state, initial] (0) {$q_0$};
		%\node[state] (1) [right of=0] {$q_1$};
		%\node[state, double] (2) [right of=1] {$q_2$};
		
		%\draw[->] (0) edge[bend left=20] node[auto] {$a,b$} (1);
		%\draw[->] (1) edge[bend left=20] node[auto] {$a$} (2)
		%edge[bend left=20] node[auto] {$b$} (0);
		%\draw[->] (2) edge[loop above] node[auto] {$a$} () 
		%edge[bend left=20] node[auto] {$b$} (1);
	%\end{tikzpicture}
	%\caption{Ein Automat, der mit Tikz erzeugt wurde}
	%\label{fig:automat}
%\end{figure}

%\begin{figure}
	%\centering
	%\includegraphics[width=8cm]{automat.jpg} 
	%\caption{Eine Automat, der als jpg-Bild eingebunden wurde (Achtung: Auflösung!)}
%\end{figure}

%\begin{theorem}[Besondere Formel]\label{theo:aussage}
	%Hier ist eine Aussage.
%\end{theorem}
%\begin{proof}
	%Hier folgt der Beweis.
%\end{proof}




\section{Zusammenfassung und Ausblick}

In dieser Ausarbeitung ging es um Min-Cost Max-Flow Problem. Wir haben sowie naive, als auch effiziente Implementierung betrachtet, die Laufzeit von beiden analysiert und die Beispielaufgaben gesehen. Ich hoffe, dass meine Ausarbeitung mehr Verständnis zu diesem Thema gebracht hat. 

%%%%%%%%%%%    Der folgende Teil zählt nicht zu Zeilenbeschränkung der Vorgabe   %%%%%%%%%%%%%%
\nolinenumbers

%%%%%%%%%%%    Literaturverzeichnis   %%%%%%%%%%%%%%
 \printbibliography 
 
 %%%%%%%%%%%    Anhang   %%%%%%%%%%%%%%
 \appendix
 
 \section{Eigenständigkeitserklärung und verwendete Hilfsmittel}
Ich versichere an Eides statt, dass ich die vorliegende Arbeit in allen Teilen selbstständig und ohne unzulässige Hilfe Dritter absolviert sowie keine anderen als die genannten und explizit zugelassenen Hilfsmittel verwendet und mich im Allgemeinen prüfungskonform verhalten habe. Ich erkläre zudem, dass ich beim Einsatz von IT-/KI-gestützten Schreibwerkzeugen diese Werkzeuge in der Übersicht verwendeter Hilfsmittel mit ihrem Produktnamen, meiner Bezugsquelle und … vollständig aufgeführt und/oder die betreffenden Textstellen in der Arbeit als mit KI generierter Unterstützung verfasst gekennzeichnet habe. Mir ist bewusst, dass Täuschungen bzw. Täuschungsversuche nach der für mich geltenden Prüfungsordnung geahndet werden.\\


Folgende Hilfsmittel habe ich für die Bearbeitung genutzt:
\begin{itemize}
    \item DeepL Übersetzer - Unterstützung bei der Übersetzung
    \item ChatGPT - sprachliche Unterstützung
\end{itemize}

 
\end{document}